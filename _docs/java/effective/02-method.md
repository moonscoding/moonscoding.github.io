## Effective Java - Method

### Item10. equals 일반 규약을 재정의하라

물리적 동치성이 아닌 논리적 동치성을 비교하도록 재정의 되지 않았을 때 사용

재정의할 필요 없는 경우

- 각 인스턴스가 본질적으로 고유
- 인스턴스의 논리적 동치성을 검사할 일이 없음
- 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어 맞음
- 클래스가 private 이거나 package-private 이고 equals 메서드를 호출할 일이 없다

```java
@Override
public boolean equals(Object o) {
  throw new AssertionError(); // 호출금지
}
```



equals 메서드 재정의시에 일반규약 ( equals 메서드는 동치관계를 구현하며 다음을 만족 )

- 반사성 - null 이 아닌 모든 참조값 x에 대해서 x,equals(x)는 true
- 대칭성 - null 이 아닌 모든 참조값 x, y에 대해서 x.euals(y) true이면  y.equals(x)도 true
- 추이성 - null 이 아닌 모든 참조값 x, y, z에 대해서 .. 위와같음
- 일관성 - null 이 아닌 모든 참조값 x, y에 대해서 x.euals(y)를 반복해서 호출해도 값이 일관
- nonNull - null 이 아닌 모든 참조값 x에 대해, x equals(null)은 false 



equals 메서드 구현 방법

- == 연산자를 사용해서 입력이 자기 자신의 참조인지 확인
- instanceof 연산자로 입력이 올바른 타입인지 확인
- 입력을 올바른 타입으로 형변환
- 입력 객체와 자기 자신의 대응되는 핵심 필드들이 모두 일치하는지 하나씩 검사



> equals 메소드를 재정의했다면 세 가지 사항에 대해서 자문하자
>
> 대칭적인가 ? 추이성이 있는가? 일관적인가?



추가주의사항

- equals를 재정의할 떈 hashCode도 반드시 재정의
- 너무 복잡하게 해결하려 들지 말자



### Item11. equals를 재정의하려거든 hashCode도 재정의

objects 명세

- equals 비교에서 사용되는 정보가 변경되지 않았다면 애플리케이션이 실행되는 동안 그 객체의 hashCode 메서드는 몇번을 호출해도 일관

  애플리케이션 재시작에서는 무관

- equals 비교가 두 객체를 같다고 판단했다면 두 객체의 hashCode는 똑같은 값을 반환

- equals 비교가 두 객체가 다르다고 판단했더라도 두 객체의 hashCoder가 서로 다른 값을 반환할 필요는 없음
  단 다른 객체에 대해서 다른 값을 반환해야 해시테이블의 성능이 좋아짐



hashCode 재정의를 잘못했을 때 크게 문제가 되는 조항은 2버 

즉 논리적으로 같은 객체는 같은 해시코드 반환



위의 규칙대로라면 다음 해시함수도 가능하다.

하지만 헤시테이블의 버킷 하나에 담겨 마치 연결 리스트 처럼 동작

```java
@Override
public int hashCode() {
  return 42;
}
```



그렇다면 좋은 해시함수란 무엇인가 ? 서로 다른 인스턴스에 다른 해시코드를 반환

이상적인 해시함수는 주어진 인스턴스들을 32비트 정수 범위에 균일하게 분배해야 함

이상을 완벽히 실현하기는 어렵지만 비슷하게 만들기는 그다지 어렵지 않음

- int 변수 result를 선언하고 값을 c로 초기화 
  이 때 c는 해당 객체의 첫 번째 해김 필드를 단계 2.a 방식으로 계산한 해시코드
- 해당 객체의 나머지 핵심 필드 f 각각에 대해 다음 작업을 수행
  - 해당 필드의 해시코드 c를 계산
  - 

